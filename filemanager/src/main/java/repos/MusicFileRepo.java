package repos;

import com.google.inject.Inject;
import exceptions.DbException;
import exceptions.ModelException;
import models.files.MusicFile;
import models.files.MusicFileSchema;
import routes.utils.PaginatedResponse;
import routes.utils.Pagination;
import routes.utils.PaginationMetadata;
import services.MusicFileService;

import java.sql.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.logging.Logger;

public class MusicFileRepo extends Repo implements MusicFileService {
    private static final Logger logger = Logger.getLogger(MusicFileRepo.class.getName());
    @Inject private MusicFileSchema schema;

    /**
     * Return a file by its primary key
     *
     * @param id file's primary key
     * @return MusicFile
     */
    @Override
    public MusicFile getById(long id) {
        String sql = String.format(
          "SELECT * FROM %s WHERE id = ?", schema.tableName()
        );
        try (
          Connection conn = db.getConnection();
          PreparedStatement stmt = conn.prepareStatement(sql);
        ) {
            stmt.setLong(1, id);
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    return schema.getModelFromResultSet(rs);
                }

                return null;
            }
        } catch (SQLException e) {
            logger.severe(e.getMessage());
            throw new DbException("Cannot get the file", DbException.SQL_EXCEPTION);
        }
    }

    /**
     * Upsert of a file into the database
     *
     * @param file The file.
     * @return The file
     */
    @Override
    public MusicFile save(MusicFile file) {
        if (!file.isValid()) {
            throw new ModelException(file.getErrors(), file.getErrorCode());
        }

        String sql;

        if (file.getId() != null) { // update
            sql = schema.getSqlForUpdate();

            try (
              Connection conn = db.getConnection();
              PreparedStatement stmt = conn.prepareStatement(sql);
            ) {
                schema.setStatementValues(stmt, file);
                int affectedRows = stmt.executeUpdate();
                logger.info("MusicFile.update, affected rows: " + affectedRows);

                if (affectedRows == 0) {
                    throw new DbException(
                      String.format("No file with id %d was found", file.getId()),
                      DbException.RESOURCE_NOT_FOUND
                    );
                }

                return file;
            } catch (SQLException e) {
                logger.severe(e.getMessage());
                throw new DbException("Updating the file failed", DbException.SQL_EXCEPTION);
            }

        } else { // create
            sql = schema.getSqlForInsert();
            int autoGeneratedKeys = Statement.RETURN_GENERATED_KEYS;

            try (
              Connection conn = db.getConnection();
              PreparedStatement stmt = conn.prepareStatement(sql, autoGeneratedKeys);
            ) {
                schema.setStatementValues(stmt, file);
                int affectedRows = stmt.executeUpdate();
                logger.info("MusicFile.create, affected rows: " + affectedRows);

                if (affectedRows == 0) {
                    throw new DbException(
                      "Insert new file failed",
                      DbException.SQL_EXCEPTION
                    );
                }

                try (ResultSet generatedKeys = stmt.getGeneratedKeys()) {
                    if (generatedKeys.next()) {
                        file.setId(generatedKeys.getLong(1));
                        return file;
                    } else {
                        throw new SQLException("Creating file failed, no ID obtained.");
                    }
                }
            } catch (SQLException e) {
                logger.severe(e.getMessage());
                throw new DbException("Cannot get the file", DbException.SQL_EXCEPTION);
            }
        }
    }

    @Override
    public long bulkSave(List<MusicFile> files) {
        String sql = schema.getSqlForInsert() + " ON DUPLICATE KEY " +
                     "UPDATE " + MusicFileSchema.ABSOLUTE_PATH  + " = ?";
        logger.fine(sql);
        try (
          Connection conn = db.getConnection();
          PreparedStatement stmt = conn.prepareStatement(sql);
        ) {
            schema.setStatementValuesForBatch(stmt, files);
            // A number greater than or equal to zero -- indicates that the command was processed
            // successfully and is an update count giving the number of rows in the database that
            // were affected by the command's execution
            return Arrays.stream(
              stmt.executeBatch()
            ).boxed().filter(r -> r == 1).count();
        } catch (SQLException e) {
            logger.severe(e.getMessage());
            throw new DbException("Updating the file failed", DbException.SQL_EXCEPTION);
        }
    }

    /**
     * Delete a file.
     *
     * @param id The file's id.
     * @return true if the operation was successful, false otherwise.
     */
    @Override
    public boolean delete(long id) {
        return false;
    }

    /**
     * A pagination-enabled list of music files.
     *
     * @param pagination How to retrieve the results.
     * @return The response with pagination info.
     */
    @Override
    public PaginatedResponse<MusicFile> getAll(Pagination pagination) {
        MusicFileSchema schema = new MusicFileSchema();

        String sql = String.format("SELECT * FROM %s", schema.tableName());
        String countSql = "";
        String cursor = pagination.getCursor(true);
        long value = 0;
        PaginationMetadata meta = new PaginationMetadata();

        if (cursor != null) {
            value = Long.parseLong(cursor);
            sql += (pagination.getSortDir().equals("desc"))
                    ? " WHERE id < ? " : " WHERE id > ? ";
        } else {
            countSql = sql;
        }

        // filters here in the future, copy sql to countSql
        if (!countSql.isBlank()) {
            meta.setTotalCount(this.count(countSql));
        }

        sql += "ORDER BY id " + pagination.getSortDir();
        sql += " LIMIT " + (pagination.getCount() + 1);

        try (
          Connection conn = db.getConnection();
          PreparedStatement stmt = conn.prepareStatement(sql);
        ) {
            if (cursor != null) {
                stmt.setLong(1, value);
            }

            List<MusicFile> items = new ArrayList<>();

            try (ResultSet rs = stmt.executeQuery()) {
                while (rs.next()) {
                    items.add(schema.getModelFromResultSet(rs));
                }

                PaginatedResponse<MusicFile> response = new PaginatedResponse<>();
                response.setItems(items);
                meta.setHasMoreData(items.size() == (pagination.getCount() + 1));

                if (meta.isHasMoreData()) {
                    long id = items.get(10).getId();
                    meta.setNextCursor(id + "");
                }

                return response.setMetadata(meta);
            }
        } catch (SQLException e) {
            logger.severe(e.getMessage());
            throw new DbException("Cannot get list of files", DbException.SQL_EXCEPTION);
        }
    }
}