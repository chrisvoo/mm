package repos;

import com.google.inject.Inject;
import exceptions.DbException;
import exceptions.ModelException;
import models.scanner.ScanOp;
import models.stats.Stats;
import models.stats.StatsSchema;
import services.StatsService;
import utils.Db;
import utils.logging.LoggerInterface;

import java.sql.*;
import java.util.Optional;

public class StatsRepo extends Repo implements StatsService {
    @Inject private LoggerInterface logger;
    @Inject private Db db;
    @Inject private StatsSchema schema;

    /**
     * Return the last record from stats or all the history
     * @return Stats
     */
    @Override
    public Stats getStats() {
        String sql = String.format("SELECT * FROM %s", schema.tableName());
        try (
            Connection conn = db.getConnection();
            PreparedStatement stmt = conn.prepareStatement(sql)
        ) {
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    return schema.getModelFromResultSet(rs);
                }

                return null;
            }
        } catch (SQLException e) {
            logger.severe(e.getMessage());
            throw new DbException("Failed to get the stats", DbException.SQL_EXCEPTION);
        }
    }

    private Stats insert(Stats stats) {
        String sql = schema.getSqlForInsert();
        int autoGeneratedKeys = Statement.RETURN_GENERATED_KEYS;
        logger.fine(sql);

        try (
          Connection conn = db.getConnection();
          PreparedStatement stmt = conn.prepareStatement(sql, autoGeneratedKeys)
        ) {
            schema.setStatementValues(stmt, stats);
            int affectedRows = stmt.executeUpdate();
            logger.fine("Stats.create, affected rows: " + affectedRows);

            if (affectedRows == 0) {
                throw new DbException(
                  "Insert new stats failed",
                  DbException.SQL_EXCEPTION
                );
            }

            try (ResultSet generatedKeys = stmt.getGeneratedKeys()) {
                if (generatedKeys.next()) {
                    stats.setId(generatedKeys.getLong(1));
                    return stats;
                } else {
                    throw new SQLException("Creating stats failed, no ID obtained.");
                }
            }
        } catch (SQLException e) {
            logger.severe(e.getMessage());
            throw new DbException("Cannot get the stats", DbException.SQL_EXCEPTION);
        }
    }

    /**
     * Upsert of the stats into the database
     *
     * @param stats The stats.
     * @return The stats
     */
    @Override
    public Stats save(Stats stats) {
        if (!stats.isValid()) {
            throw new ModelException(stats.getErrors(), stats.getErrorCode());
        }

        Stats oldStats = this.getStats();

        if (oldStats == null) {
            return this.insert(stats);
        }

        stats.setId(oldStats.getId());

        String sql = schema.getSqlForUpdate();

        try (
            Connection conn = db.getConnection();
            PreparedStatement stmt = conn.prepareStatement(sql)
        ) {
            schema.setStatementValues(stmt, stats);
            int affectedRows = stmt.executeUpdate();
            logger.fine("Stats.update, affected rows: " + affectedRows);

            if (affectedRows == 0) {
                throw new DbException(
                    String.format("No stats with id %d was found", stats.getId()),
                    DbException.RESOURCE_NOT_FOUND
                );
            }

            return stats;
        } catch (SQLException e) {
            logger.severe(e.getMessage());
            throw new DbException("Updating the stats failed", DbException.SQL_EXCEPTION);
        }
    }

    @Override
    public Stats save(ScanOp op) {
        if (op == null) {
            logger.info("Nothing to save");
            return null;
        }

        Stats stats = Optional.ofNullable(this.getStats())
                              .orElse(new Stats());

        return this.save(
          stats
            .addTotalBytes(op.getTotalBytes())
            .addTotalFiles(op.getTotalFilesInserted())
        );
    }
}