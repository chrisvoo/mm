package repos;

import com.google.inject.Inject;
import exceptions.DbException;
import exceptions.ModelException;
import models.scanner.ScanOp;
import models.scanner.ScanOpSchema;
import models.stats.StatsSchema;
import services.ScannerService;
import utils.Db;
import utils.logging.LoggerInterface;

import java.sql.*;

public class ScannerRepo implements ScannerService {
    @Inject private LoggerInterface logger;
    @Inject private Db db;
    @Inject private ScanOpSchema schema;
    @Inject private StatsSchema statsSchema;


    /**
     * Add a new result of a scanning operation.
     *
     * @param op op The operation
     * @return long The ScanOp primary key
     */
    @Override
    public ScanOp save(ScanOp op) {
        if (!op.isValid()) {
            throw new ModelException(op.getErrors(), op.getErrorCode());
        }

        String sql;

        if (op.getId() != null) { // update
            sql = schema.getSqlForUpdate();

            try (
              Connection conn = db.getConnection();
              PreparedStatement stmt = conn.prepareStatement(sql)
            ) {
                schema.setStatementValues(stmt, op);
                int affectedRows = stmt.executeUpdate();
                logger.fine("ScanOp.update, affected rows: " + affectedRows);

                if (affectedRows == 0) {
                    throw new DbException(
                      String.format("No scanop with id %d was found", op.getId()),
                      DbException.RESOURCE_NOT_FOUND
                    );
                }
            } catch (SQLException e) {
                logger.severe(e.getMessage());
                throw new DbException("Updating the scanop failed", DbException.SQL_EXCEPTION);
            }

        } else { // create
            sql = schema.getSqlForInsert();
            int autoGeneratedKeys = Statement.RETURN_GENERATED_KEYS;

            try (
              Connection conn = db.getConnection();
              PreparedStatement stmt = conn.prepareStatement(sql, autoGeneratedKeys)
            ) {
                schema.setStatementValues(stmt, op);
                int affectedRows = stmt.executeUpdate();
                logger.fine("ScanOp.create, affected rows: " + affectedRows);

                if (affectedRows == 0) {
                    throw new DbException(
                      "Insert new scanop failed",
                      DbException.SQL_EXCEPTION
                    );
                }

                try (ResultSet generatedKeys = stmt.getGeneratedKeys()) {
                    if (generatedKeys.next()) {
                        op.setId(generatedKeys.getLong(1));
                    } else {
                        throw new SQLException("Creating scanop failed, no ID obtained.");
                    }
                }
            } catch (SQLException e) {
                logger.severe(e.getMessage());
                throw new DbException("Cannot get the scanop", DbException.SQL_EXCEPTION);
            }
        }

        this.saveStats(op);
        return op;
    }

    /**
     * Saves the stats of the last scan
     * @param result The result of the scan
     */
    private void saveStats(ScanOp result) {
        String sql = statsSchema.getSqlForInsert();
        try (
          Connection conn = db.getConnection();
          PreparedStatement stmt = conn.prepareStatement(sql)
        ) {
            statsSchema.setStatementValues(stmt, result.getStats());
            int affectedRows = stmt.executeUpdate();
            logger.fine("statsSchema.create, affected rows: " + affectedRows);

            if (affectedRows == 0) {
                throw new DbException(
                  "Insert new stats failed",
                  DbException.SQL_EXCEPTION
                );
            }
        } catch (SQLException e) {
            logger.severe(e.getMessage());
            throw new DbException("Cannot insert the stats", DbException.SQL_EXCEPTION);
        }
    }

    /**
     * The scan op corresponding to the specified id.
     *
     * @param id The scanOp primary key
     * @return ScanOp the operation instance
     */
    @Override
    public ScanOp getById(long id) {
        String sql = String.format(
          "SELECT * FROM %s WHERE id = ?", schema.tableName()
        );
        try (
          Connection conn = db.getConnection();
          PreparedStatement stmt = conn.prepareStatement(sql)
        ) {
            stmt.setLong(1, id);
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    return schema.getModelFromResultSet(rs);
                }

                return null;
            }
        } catch (SQLException e) {
            logger.severe(e.getMessage());
            throw new DbException("Failed to get the scanop", DbException.SQL_EXCEPTION);
        }
    }
}