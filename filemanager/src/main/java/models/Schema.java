package models;

import utils.Conv;

import java.sql.*;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.logging.Logger;
import java.util.stream.Stream;

public abstract class Schema<T> {
    protected List<String> fields;
    protected List<String> primaryKeys;
    private static final Logger logger = Logger.getLogger(Schema.class.getName());

    /**
     * The MySQL table for this model
     * @return The table's name.
     */
    public abstract String tableName();

    /**
     * Return the fields with or without primary keys. This is done on purpose since
     * most of the time we use autogenerated keys.
     * @return The list of fields without primary keys.
     */
    public List<String> getFields(boolean includePrimaryKeys) {
        return includePrimaryKeys
          ? Stream.concat(this.primaryKeys.stream(), this.fields.stream()).toList()
          : this.fields;
    }

    /**
     * Return all fields but the ones specified in the exclusion list
     * @param exclusionList A list of fields to be excluded.
     * @return The final desired list.
     */
    public List<String> getFields(List<String> exclusionList) {
        if (exclusionList.isEmpty()) {
            return this.fields;
        }

        // do not modify the original list
        List<String> newList = new ArrayList<>(this.fields);
        newList.removeAll(exclusionList);
        return newList;
    }

    /**
     * List of primary keys
     * @return The primary keys.
     */
    public List<String> getPrimaryKeys() {
        return this.primaryKeys;
    }

    /**
     * Produces the INSERT statement for a model using its defined schema.
     * @param includePrimaryKeys If the primary key should be included in the generated SQL.
     * @return The SQL with fields names and placeholders.
     */
    public String getSqlForInsert(boolean includePrimaryKeys) {
        List<String> finalFields = this.getFields(includePrimaryKeys);
        String names = String.join(",", finalFields);

        List<String> list = new ArrayList<>(Collections.nCopies(finalFields.size(), "?"));
        String placeholders = String.join(",", list);

        String sql = String.format(
          "INSERT INTO %s (:fields) VALUES (%s)",
          this.tableName(), placeholders
        ).replace(":fields", names);

        logger.fine(sql);
        return sql;
    }

    /**
     * Produces the INSERT statement for a model using its defined schema.
     * @return The SQL with fields names and placeholders.
     */
    public String getSqlForInsert() {
        return this.getSqlForInsert(false);
    }

    /**
     * Produces the UPDATE statement for a model using its defined schema.
     * @return The SQL with fields names and placeholders.
     */
    public String getSqlForUpdate() {
        List<String> fList = new ArrayList<>(Collections.nCopies(this.fields.size(),"%s = ?"));

        for (int i = 0; i < fList.size(); i++) {
            fList.set(i, String.format(fList.get(i), this.fields.get(i)));
        }

        List<String> pList = new ArrayList<>(Collections.nCopies(this.primaryKeys.size(), "%s = ?"));
        for (int i = 0; i < pList.size(); i++) {
            pList.set(i, String.format(pList.get(i), this.primaryKeys.get(i)));
        }

        String whereStatement = (pList.size() == 1)
          ? "WHERE " + pList.get(0)
          : "WHERE " + String.join(" AND ", pList);

        String sql = String.format(
            "UPDATE %s SET %s %s",
            this.tableName(), String.join(",", fList), whereStatement
        );

        logger.fine(sql);
        return sql;
    }

    /**
     * Produces the DELETE statement for a model using its defined schema.
     * @return The SQL with fields names and placeholders.
     */
    public String getSqlForDelete() {
        List<String> pList = new ArrayList<>(Collections.nCopies(this.primaryKeys.size(), "%s = ?"));
        for (int i = 0; i < pList.size(); i++) {
            pList.set(i, String.format(pList.get(i), this.primaryKeys.get(i)));
        }

        String whereStatement = (pList.size() == 1)
          ? "WHERE " + pList.get(0)
          : "WHERE " + String.join(" AND ", pList);

        String sql = String.format(
          "DELETE FROM %s %s",
          this.tableName(), whereStatement
        );

        logger.fine(sql);
        return sql;
    }

    /**
     * Returns the long value from a resultset
     * @param rs The resultset
     * @param field The field name
     * @return The value
     * @throws SQLException An exception that provides information on a database access error or other errors.
     */
    protected Long getLong(ResultSet rs, String field) throws SQLException {
        long num = rs.getLong(field);
        if (num == 0) {
            return null;
        }

        return num;
    }

    /**
     * Sets a placeholder of a prepared statement.
     * @param stmt The prepared statement-
     * @param num The long value.
     * @param index The index
     * @throws SQLException An exception that provides information on a database access error or other errors.
     */
    protected void setLong(PreparedStatement stmt, Long num, int index) throws SQLException {
        if (num != null) {
            stmt.setLong(index, num);
        } else {
            stmt.setNull(index, Types.BIGINT);
        }
    }

    /**
     * Returns the int value from a resultset
     * @param rs The resultset
     * @param field The field name
     * @return The value
     * @throws SQLException An exception that provides information on a database access error or other errors.
     */
    protected Integer getInt(ResultSet rs, String field) throws SQLException {
        int num = rs.getInt(field);
        if (num == 0) {
            return null;
        }

        return num;
    }

    /**
     * Sets a placeholder of a prepared statement.
     * @param stmt The prepared statement-
     * @param num The int value.
     * @param index The index
     * @throws SQLException An exception that provides information on a database access error or other errors.
     */
    protected void setInt(PreparedStatement stmt, Integer num, int index) throws SQLException {
        if (num != null) {
            stmt.setInt(index, num);
        } else {
            stmt.setNull(index, Types.INTEGER);
        }
    }

    /**
     * Returns the int value from a resultset
     * @param rs The resultset
     * @param field The field name
     * @return The value
     * @throws SQLException An exception that provides information on a database access error or other errors.
     */
    protected Byte[] getBytes(ResultSet rs, String field) throws SQLException {
        byte[] num = rs.getBytes(field);
        return Conv.byteToByte(num);
    }

    /**
     * Sets a placeholder of a prepared statement.
     * @param stmt The prepared statement-
     * @param num The int value.
     * @param index The index
     * @throws SQLException An exception that provides information on a database access error or other errors.
     */
    protected void setBytes(PreparedStatement stmt, Byte[] num, int index) throws SQLException {
        byte[] bytes = Conv.ByteTobyte(num);
        if (bytes != null) {
            stmt.setBytes(index, bytes);
        } else {
            stmt.setNull(index, Types.BLOB);
        }
    }

    /**
     * Sets a placeholder of a prepared statement.
     * @param stmt The prepared statement.
     * @param num The short value.
     * @param index The index
     * @throws SQLException An exception that provides information on a database access error or other errors.
     */
    protected void setTimestamp(PreparedStatement stmt, Timestamp ts, int index) throws SQLException {
        if (ts != null) {
            stmt.setTimestamp(index, ts);
        } else {
            stmt.setNull(index, Types.TIMESTAMP);
        }
    }

    /**
     * Returns the short value from a resultset
     * @param rs The resultset
     * @param field The field name
     * @return The value
     * @throws SQLException An exception that provides information on a database access error or other errors.
     */
    protected Short getShort(ResultSet rs, String field) throws SQLException {
        short num = rs.getShort(field);
        if (num == 0) {
            return null;
        }

        return num;
    }

    /**
     * Sets a placeholder of a prepared statement.
     * @param stmt The prepared statement.
     * @param num The short value.
     * @param index The index
     * @throws SQLException An exception that provides information on a database access error or other errors.
     */
    protected void setShort(PreparedStatement stmt, Short num, int index) throws SQLException {
        if (num != null) {
            stmt.setShort(index, num);
        } else {
            stmt.setNull(index, Types.TINYINT);
        }
    }

    /**
     * Builds a model from a resultset
     * @param rs The resultset.
     * @return The model
     * @throws SQLException An exception that provides information on a database access error or other errors.
     */
    public abstract T getModelFromResultSet(ResultSet rs) throws SQLException;

    /**
     * Sets the prepared statement's placeholders.
     * @param stmt The prepared statement.
     * @param instance A model to be initialized.
     * @throws SQLException An exception that provides information on a database access error or other errors.
     */
    public abstract void setStatementValues(PreparedStatement stmt, T instance) throws SQLException;
}