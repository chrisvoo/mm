package models;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Types;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.logging.Logger;
import java.util.stream.Stream;

public abstract class Schema<T> {
    protected List<String> fields;
    protected List<String> primaryKeys;
    private static final Logger logger = Logger.getLogger(Schema.class.getName());

    /**
     * The MySQL table for this model
     * @return The table's name.
     */
    public abstract String tableName();

    /**
     * Return the fields with or without primary keys. This is done on purpose since
     * most of the time we use autogenerated keys.
     * @return The list of fields without primary keys.
     */
    public List<String> getFields(boolean includePrimaryKeys) {
        return includePrimaryKeys
          ? Stream.concat(this.primaryKeys.stream(), this.fields.stream()).toList()
          : this.fields;
    }

    /**
     * List of primary keys
     * @return The primary keys.
     */
    public List<String> getPrimaryKeys() {
        return this.primaryKeys;
    }

    public String getSqlForInsert(boolean includePrimaryKeys) {
        List<String> finalFields = this.getFields(includePrimaryKeys);
        String names = String.join(",", finalFields);

        List<String> list = new ArrayList<>(Collections.nCopies(finalFields.size(), "?"));
        String placeholders = String.join(",", list);

        String sql = String.format(
          "INSERT INTO %s (:fields) VALUES (%s)",
          this.tableName(), placeholders
        ).replace(":fields", names);

        logger.fine(sql);
        return sql;
    }

    public String getSqlForInsert() {
        return this.getSqlForInsert(false);
    }

    public String getSqlForUpdate() {
        List<String> fList = new ArrayList<>(Collections.nCopies(this.fields.size(),"%s = ?"));

        for (int i = 0; i < fList.size(); i++) {
            fList.set(i, String.format(fList.get(i), this.fields.get(i)));
        }

        List<String> pList = new ArrayList<>(Collections.nCopies(this.primaryKeys.size(), "%s = ?"));
        for (int i = 0; i < pList.size(); i++) {
            pList.set(i, String.format(pList.get(i), this.primaryKeys.get(i)));
        }

        String whereStatement = (pList.size() == 1)
          ? "WHERE " + pList.get(0)
          : "WHERE " + String.join(" AND ", pList);

        String sql = String.format(
            "UPDATE %s SET %s %s",
            this.tableName(), String.join(",", fList), whereStatement
        );

        logger.fine(sql);
        return sql;
    }

    protected Long getLong(ResultSet rs, String field) throws SQLException {
        long num = rs.getLong(field);
        if (num == 0) {
            return null;
        }

        return num;
    }

    protected void setLong(PreparedStatement stmt, Long num, int index) throws SQLException {
        if (num != null) {
            stmt.setLong(index, num);
        } else {
            stmt.setNull(index, Types.BIGINT);
        }
    }

    protected Short getShort(ResultSet rs, String field) throws SQLException {
        short num = rs.getShort(field);
        if (num == 0) {
            return null;
        }

        return num;
    }

    protected void setShort(PreparedStatement stmt, Short num, int index) throws SQLException {
        if (num != null) {
            stmt.setShort(index, num);
        } else {
            stmt.setNull(index, Types.TINYINT);
        }
    }

    public abstract T getModelFromResultSet(ResultSet rs) throws SQLException;

    public abstract void setStatementValues(PreparedStatement stmt, T instance) throws SQLException;
}